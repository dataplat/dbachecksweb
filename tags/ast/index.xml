<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Ast on dbachecks</title><link>https://dbachecks.io/tags/ast/</link><description>Recent content in Ast on dbachecks</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Thu, 16 Aug 2018 00:00:00 +0000</lastBuildDate><atom:link href="https://dbachecks.io/tags/ast/index.xml" rel="self" type="application/rss+xml"/><item><title>Using the PowerShell AST to find a ForEach Method</title><link>https://dbachecks.io/blog/using-the-powershell-ast-to-find-a-foreach-method/</link><pubDate>Thu, 16 Aug 2018 00:00:00 +0000</pubDate><guid>https://dbachecks.io/blog/using-the-powershell-ast-to-find-a-foreach-method/</guid><description>&lt;img src="https://dbachecks.io/assets/uploads/2018/08/server.png" alt="Featured image of post Using the PowerShell AST to find a ForEach Method" />&lt;p>In &lt;a class="link" href="http://dbachecks.io" target="_blank" rel="noopener"
>dbachecks&lt;/a>Â we enable people to see what checks are available by running Get-DbcCheck. This gives a number of properties including the â€˜typeâ€™ of check. This refers to the configuration item or parameter that is required to have a value for this check to run.&lt;/p>
&lt;p>For example â€“ Any check to do with SQL Agent is of type Sqlinstance because it requires an instance to be specified but a check for SPN is of type ComputerName because it requires a computer name to run.&lt;/p>
&lt;h2 id="automation-for-the-win">Automation for the win
&lt;/h2>&lt;p>Because I believe in automation I do not want to have to hard code these values anywhere but create them when the module is imported so we use a json file to feed Get-DbcCheck and populate the Json file when we import the module. This is done using the &lt;a class="link" href="https://dbachecks.io/using-the-ast-in-pester-for-dbachecks/" >method that I described here&lt;/a> and means that whenever a new check is added it is automatically available in Get-DbcCheck without any extra work.&lt;/p>
&lt;p>We use code like this&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">## Parse the file with AST
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$CheckFileAST = [Management.Automation.Language.Parser]::ParseInput($check, [ref]$null, [ref]$null)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">## Old code we can use the describes
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$Describes = $CheckFileAST.FindAll([Func[Management.Automation.Language.Ast, bool]] {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> param ($ast)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> $ast.CommandElements -and
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> $ast.CommandElements[0].Value -eq &amp;#39;describe&amp;#39;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }, $true)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">@($describes).ForEach{
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> $groups += $filename
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> $Describe = $_.CommandElements.Where{$PSItem.StaticType.name -eq &amp;#39;string&amp;#39;}[1]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> $title = $Describe.Value
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> $Tags = $PSItem.CommandElements.Where{$PSItem.StaticType.name -eq &amp;#39;Object[]&amp;#39; -and $psitem.Value -eq $null}.Extent.Text.ToString().Replace(&amp;#39;, $filename&amp;#39;, &amp;#39;&amp;#39;)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> # CHoose the type
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if ($Describe.Parent -match &amp;#34;Get-Instance&amp;#34;) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> $type = &amp;#34;Sqlinstance&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> elseif ($Describe.Parent -match &amp;#34;Get-ComputerName&amp;#34; -or $Describe.Parent -match &amp;#34;AllServerInfo&amp;#34;) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> $type = &amp;#34;ComputerName&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> elseif ($Describe.Parent -match &amp;#34;Get-ClusterObject&amp;#34;) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> $Type = &amp;#34;ClusteNode&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>First we parse the code with the AST and store that in theÂ CheckFileAST variable, then we use the FindAll method to find any command elements that match â€œDescribeâ€ which conveniently gets our describes and then we can simply match the Parent object which holds some code to each function that we use to get our values to be passed to the testsÂ &lt;code>Get-ComputerName&lt;/code>,Â &lt;code>Get-Instance&lt;/code>,Â &lt;code>Get-ClusterObject&lt;/code> and set the type appropriately.&lt;/p>
&lt;p>which when run against a check like this&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">Describe &amp;#34;Backup Path Access&amp;#34; -Tags BackupPathAccess, Storage, DISA, $filename {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> @(Get-Instance).ForEach{
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if ($NotContactable -contains $psitem) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Context &amp;#34;Testing Backup Path Access on $psitem&amp;#34; {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> It &amp;#34;Can&amp;#39;t Connect to $Psitem&amp;#34; {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> $false| Should -BeTrue -Because &amp;#34;The instance should be available to be connected to!&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> else {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Context &amp;#34;Testing Backup Path Access on $psitem&amp;#34; {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> $backuppath = Get-DbcConfigValue policy.storage.backuppath
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if (-not$backuppath) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> $backuppath = (Get-DbaDefaultPath-SqlInstance $psitem).Backup
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> It &amp;#34;can access backup path ($backuppath) on $psitem&amp;#34; {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Test-DbaSqlPath-SqlInstance $psitem -Path $backuppath| Should -BeTrue -Because &amp;#39;The SQL Service account needs to have access to the backup path to backup your databases&amp;#39;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>will find the describe block and get the title â€œBackup Path Accessâ€Â  and the tags BackupPathAccess, Storage, DISA, $filename and then find theÂ Get-Instance and set the type to SqlInstance&lt;/p>
&lt;h2 id="until-rob-breaks-it">Until Rob breaks it!
&lt;/h2>&lt;p>This has worked wonderfully well for 6 months or so of the life of dbachecks but this week I broke it!&lt;/p>
&lt;p>The problem was the performance of the code. It is taking a long time to run the tests and I am looking at ways to improve this. I was looking at the Server.Tests file because I thought why not start with one of the smaller files.&lt;/p>
&lt;p>It runs the following checks&lt;/p>
&lt;ul>
&lt;li>Server Power Plan Configuration&lt;/li>
&lt;li>SPNs&lt;/li>
&lt;li>Disk Space&lt;/li>
&lt;li>Ping Computer&lt;/li>
&lt;li>CPUPrioritisation&lt;/li>
&lt;li>Disk Allocation Unit&lt;/li>
&lt;li>Instance Connection&lt;/li>
&lt;/ul>
&lt;p>and it was looping through the computer names for each check like this&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">Describe &amp;#34;Server Power Plan Configuration&amp;#34; -Tags PowerPlan, $filename {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> @(Get-ComputerName).ForEach{
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Describe &amp;#34;Instance Connection&amp;#34; -Tags InstanceConnection, Connectivity, $filename {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> @(Get-Instance).ForEach{
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Describe &amp;#34;SPNs&amp;#34; -Tags SPN, $filename {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> @(Get-ComputerName).ForEach{
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Describe &amp;#34;Disk Space&amp;#34; -Tags DiskCapacity, Storage, DISA, $filename {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> @(Get-ComputerName).ForEach{
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Describe &amp;#34;Ping Computer&amp;#34; -Tags PingComputer, $filename {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> @(Get-ComputerName).ForEach{
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Describe &amp;#34;CPUPrioritisation&amp;#34; -Tags CPUPrioritisation, $filename {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> @(Get-ComputerName).ForEach{
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Describe &amp;#34;Disk Allocation Unit&amp;#34; -Tags DiskAllocationUnit, $filename {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> @(Get-ComputerName).ForEach{
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>I altered it to have only one loop for the computer names like so&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">@(Get-ComputerName).ForEach{
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Describe &amp;#34;Server Power Plan Configuration&amp;#34; -Tags PowerPlan, $filename {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Describe &amp;#34;SPNs&amp;#34; -Tags SPN, $filename {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Describe &amp;#34;Disk Space&amp;#34; -Tags DiskCapacity, Storage, DISA, $filename {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Describe &amp;#34;Ping Computer&amp;#34; -Tags PingComputer, $filename {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Describe &amp;#34;CPUPrioritisation&amp;#34; -Tags CPUPrioritisation, $filename {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Describe &amp;#34;Disk Allocation Unit&amp;#34; -Tags DiskAllocationUnit, $filename {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Describe &amp;#34;Instance Connection&amp;#34; -Tags InstanceConnection, Connectivity, $filename {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> @(Get-Instance).ForEach{
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>and immediately in testing my checks for the Server Tag decreased in time by about 60% ðŸ™‚&lt;/p>
&lt;p>I was very happy.&lt;/p>
&lt;p>Then I added it to the dbachecks module on my machine, loaded the module and realised that my Json file for &lt;code>Get-DbcCheck &lt;/code>was no longer being populated for the type because this line&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">elseif ($Describe.Parent-match&amp;#34;Get-ComputerName&amp;#34;-or$Describe.Parent-match&amp;#34;AllServerInfo&amp;#34;)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>was no longer true.&lt;/p>
&lt;h2 id="ast-for-other-things">AST for other things
&lt;/h2>&lt;p>So I googled &lt;a class="link" href="http://Management.Automation.Language.Ast" target="_blank" rel="noopener"
>Management.Automation.Language.Ast&lt;/a>Â the first result lead me to &lt;a class="link" href="https://docs.microsoft.com/en-us/dotnet/api/system.management.automation.language.invokememberexpressionast?view=powershellsdk-1.1.0" target="_blank" rel="noopener"
>docs.microsoft&lt;/a>Â There are a number of different language elements available there and I foundÂ &lt;a class="link" href="https://docs.microsoft.com/en-us/dotnet/api/system.management.automation.language.invokememberexpressionast?view=powershellsdk-1.1.0" target="_blank" rel="noopener"
>InvokeMemberExpressionAst&lt;/a>Â which will let me find any methods that have been invoked, so now I can find the loops with&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">$ComputerNameForEach = $CheckFileAST.FindAll([Func[Management.Automation.Language.Ast, bool]] {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> param ($ast)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> $ast -is [System.Management.Automation.Language.InvokeMemberExpressionAst]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }, $true)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>When I examined the object returned I could see that I could further limit the result to get only the method for Get-ComputerName and then if I choose the Extent I can get the code of that loop&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">## New code uses a Computer Name loop to speed up execution so need to find that as well
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ComputerNameForEach=$CheckFileAST.FindAll([Func[Management.Automation.Language.Ast,bool]] {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">param ($ast)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$ast-is [System.Management.Automation.Language.InvokeMemberExpressionAst] -and$ast.expression.Subexpression.Extent.Text-eq&amp;#39;Get-ComputerName&amp;#39;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}, $true).Extent
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>and now I can match the Tags to the type again :-)&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">if ($ComputerNameForEach-match$title) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">$type=&amp;#34;ComputerName&amp;#34;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>and now &lt;code>Get-DbcCheck&lt;/code> is returning the right results and the checks are a little faster&lt;/p>
&lt;p>&lt;a class="link" href="assets/uploads/2018/08/server.png" >&lt;img src="https://dbachecks.io/assets/uploads/2018/08/server.png"
loading="lazy"
>&lt;/a>&lt;/p>
&lt;p>You can find &lt;a class="link" href="http://powershellgallery.com/packages/dbachecks" target="_blank" rel="noopener"
>dbachecks on the PowerShell Gallery&lt;/a> or install it using&lt;/p>
&lt;p>Install-Module dbachecks -Scope CurrentUser&lt;/p></description></item><item><title>Using the AST in Pester for dbachecks</title><link>https://dbachecks.io/blog/using-the-ast-in-pester-for-dbachecks/</link><pubDate>Mon, 15 Jan 2018 00:00:00 +0000</pubDate><guid>https://dbachecks.io/blog/using-the-ast-in-pester-for-dbachecks/</guid><description>&lt;img src="https://dbachecks.io/assets/uploads/2018/01/02-Pester-results-1.png" alt="Featured image of post Using the AST in Pester for dbachecks" />&lt;p>TagLine â€“ My goal â€“ Chrissy will appreciate Unit Tests one day ðŸ™‚&lt;/p>
&lt;p>&lt;a class="link" href="https://dbatools.io/new-module-coming-soon/" target="_blank" rel="noopener"
>Chrissy has written about dbachecks&lt;/a> the new up and coming community driven open source PowerShell module for SQL DBAs to validate their SQL Server estate. we have taken some of the ideas that we have presented about a way of using &lt;a class="link" href="http://dbatools.io" target="_blank" rel="noopener"
>dbatools&lt;/a> with &lt;a class="link" href="https://github.com/Pester/Pester" target="_blank" rel="noopener"
>Pester&lt;/a> to validate that everything is how it should be and placed them into a meta data driven framework to make things easy for anyone to use. It is looking really good and I am really excited about it. It will be released very soon.&lt;/p>
&lt;p>Chrissy and I will be doing a pre-con at &lt;a class="link" href="http://sqlbits.com" target="_blank" rel="noopener"
>SQLBits&lt;/a> where we will talk in detail about how this works. &lt;a class="link" href="http://sqlbits.com/information/event17/Reliable_Repeatable__Automated_PowerShell_for_DBAs/trainingdetails.aspx" target="_blank" rel="noopener"
>You can find out more and sign up here&lt;/a>&lt;/p>
&lt;p>&lt;a class="link" href="https://claudioessilva.eu/" target="_blank" rel="noopener"
>ClÃ¡udio Silva&lt;/a> has improved my &lt;a class="link" href="https://blog.robsewell.com/a-pretty-powerbi-pester-results-template-file/" target="_blank" rel="noopener"
>PowerBi For Pester&lt;/a>Â file and made it beautiful and whilst we were discussing this we found that if the Pester Tests were not formatted correctly the Power Bi looked â€¦ well rubbish to be honest! Chrissy asked if we could enforce some rules for writing our Pester tests.&lt;/p>
&lt;p>The rules were&lt;/p>
&lt;p>The Describe title should be in double quotes&lt;br>
The Describe should use the plural Tags parameter&lt;br>
The Tags should be singular&lt;br>
The first Tag should be a unique tag in Get-DbcConfig&lt;br>
The context title should end with $psitem&lt;br>
The code should use Get-SqlInstance or Get-ComputerName&lt;br>
The Code should use the forEach method&lt;br>
The code should not use $_&lt;br>
The code should contain a Context block&lt;/p>
&lt;p>She asked me if I could write the Pester Tests for it and this is how I did it. I needed to look at the Tags parameter for the Describe. It occurred to me that this was a job for the Abstract Syntax Tree (AST). I donâ€™t know very much about the this but I sort of remembered reading a blog post by &lt;a class="link" href="http://www.lazywinadmin.com/2016/08/powershellpester-make-sure-your.html" target="_blank" rel="noopener"
>Francois-Xavier Cat about using it with Pester&lt;/a> so I went and read that and &lt;a class="link" href="https://stackoverflow.com/questions/39909021/parsing-powershell-script-with-ast" target="_blank" rel="noopener"
>found an answer on Stack Overflow&lt;/a> as well. These looked just like what I needed so I made use of them. Thank you very much to Francois-Xavier and wOxxOm for sharing.&lt;/p>
&lt;p>The first thing I did was to get the Pester Tests which we have located in a checks folder and loop through them and get the content of the file with the Raw parameter&lt;/p>
&lt;pre>&lt;code>Context &amp;quot;$($_.Name) - Checking Describes titles and tags&amp;quot; {
&lt;/code>&lt;/pre>
&lt;p>Then I decided to look at the Describes using the method thatÂ wOxxOm (I know no more about this person!) showed.&lt;/p>
&lt;pre>&lt;code>$Describes = \[Management.Automation.Language.Parser\] ::ParseInput($check, \[ref\]$tokens, \[ref\]$errors).
FindAll(\[Func\[Management.Automation.Language.Ast, bool\]\] {
param($ast)
$ast.CommandElements -and
$ast.CommandElements\[0\].Value -eq 'describe'
}, $true) |
ForEach {
$CE = $_.CommandElements
$secondString = ($CE |Where { $_.StaticType.name -eq 'string' })\[1\]
$tagIdx = $CE.IndexOf(($CE |Where ParameterName -eq'Tags') ) + 1
$tags = if ($tagIdx -and $tagIdx -lt $CE.Count) {
$CE\[$tagIdx\].Extent
}
New-Object PSCustomObject -Property @{
Name = $secondString
Tags = $tags
}
}
&lt;/code>&lt;/pre>
&lt;p>As I understand it, this code is using the Parser on the $check (which contains the code from the file) and finding all of the Describe commands and creating an object of the title of the Describe with the StaticType equal to String and values from the Tag parameter.&lt;/p>
&lt;p>When I ran this against the database tests file I got the following results&lt;/p>
&lt;p>&lt;img src="https://blog.robsewell.com/assets/uploads/2018/01/01-describes-1.png"
loading="lazy"
>&lt;/p>
&lt;p>Then it was a simple case of writing some tests for the values&lt;/p>
&lt;pre>&lt;code>@($describes).Foreach{
$title = $PSItem.Name.ToString().Trim('&amp;quot;').Trim('''')
It &amp;quot;$title Should Use a double quote after the Describe&amp;quot; {
$PSItem.Name.ToString().Startswith('&amp;quot;')| Should be $true
$PSItem.Name.ToString().Endswith('&amp;quot;')| Should be $true
}
It &amp;quot;$title should use a plural for tags&amp;quot; {
$PsItem.Tags| Should Not BeNullOrEmpty
}
# a simple test for no esses apart from statistics and Access!!
if ($null -ne $PSItem.Tags) {
$PSItem.Tags.Text.Split(',').Trim().Where{($_ -ne '$filename') -and ($_ -notlike '\*statistics\*') -and ($_ -notlike '\*BackupPathAccess\*') }.ForEach{
It &amp;quot;$PsItem Should Be Singular&amp;quot; {
$_.ToString().Endswith('s')| Should Be $False
}
}
It &amp;quot;The first Tag Should Be in the unique Tags returned from Get-DbcCheck&amp;quot; {
$UniqueTags -contains $PSItem.Tags.Text.Split(',') \[0\].ToString()| Should Be $true
}
}
else {
It &amp;quot;You haven't used the Tags Parameter so we can't check the tags&amp;quot; {
$false| Should be $true
}
}
}
&lt;/code>&lt;/pre>
&lt;p>The Describes variable is inside @() so that if there is only one the ForEach Method will still work. The unique tags are returned from our command Get-DbcCheck which shows all of the checks. We will have a unique tag for each test so that they can be run individually.&lt;/p>
&lt;p>Yes, I have tried to ensure that the tags are singular by ensuring that they do not end with an s (apart from statistics) and so had to not checkÂ  BackupPathAccess and statistics. Filename is a variable that we add to each Describe Tags so that we can run all of the tests in one file. I added a little if block to the Pester as well so that the error if the Tags parameter was not passed was more obvious&lt;/p>
&lt;p>I did the same with the context blocks as well&lt;/p>
&lt;pre>&lt;code>Context &amp;quot;$($_.Name) - Checking Contexts&amp;quot; {
## Find the Contexts
$Contexts = \[Management.Automation.Language.Parser\] ::ParseInput($check, \[ref\]$tokens, \[ref\]$errors).
FindAll(\[Func\[Management.Automation.Language.Ast, bool\] \] {
param($ast)
$ast.CommandElements -and
$ast.CommandElements\[0\].Value -eq 'Context'
}, $true) |
ForEach {
$CE = $_.CommandElements
$secondString = ($CE |Where { $_.StaticType.name -eq 'string' })\[1\]
New-Object PSCustomObject -Property @{
Name = $secondString
}
}
@($Contexts).ForEach{
$title = $PSItem.Name.ToString().Trim('&amp;quot;').Trim('''')
It &amp;quot;$Title Should end with `$psitem So that the PowerBi will work correctly&amp;quot; {
$PSItem.Name.ToString().Endswith('psitem&amp;quot;')| Should Be $true
}
}
}
&lt;/code>&lt;/pre>
&lt;p>This time we look for the Context command and ensure that the string value ends with psitem as the PowerBi parses the last value when creating columns&lt;/p>
&lt;p>Finally I got all of the code and check if it matches some coding standards&lt;/p>
&lt;pre>&lt;code>Context &amp;quot;$($_.Name) - Checking Code&amp;quot; {
## This just grabs all the code
$AST = \[System.Management.Automation.Language.Parser\] ::ParseInput($Check, \[ref\]$null, \[ref\]$null)
$Statements = $AST.EndBlock.statements.Extent
## Ignore the filename line
@($Statements.Where{$_.StartLineNumber -ne 1}).ForEach{
$title = \[regex\]::matches($PSItem.text, &amp;quot;Describe(. *)-Tag&amp;quot;).groups\[1\].value.Replace('&amp;quot;', '').Replace ('''', '').trim()
It &amp;quot;$title Should Use Get-SqlInstance or Get-ComputerName&amp;quot; {
($PSItem.text -Match 'Get-SqlInstance') -or ($psitem.text -match 'Get-ComputerName')| Should be $true
}
It &amp;quot;$title Should use the ForEach Method&amp;quot; {
($Psitem.text -match 'Get-SqlInstance\\).ForEach {') -or ($Psitem.text -match 'Get-ComputerName\\). ForEach{')| Should Be $true# use the \ to escape the )
}
It &amp;quot;$title Should not use `$_&amp;quot; {
($Psitem.text -match '$_')| Should Be $false
}
It &amp;quot;$title Should Contain a Context Block&amp;quot; {
$Psitem.text -match 'Context'| Should Be $True
}
}
&lt;/code>&lt;/pre>
&lt;p>I trim the title from the Describe block so that it is easy to see where the failures (or passes) are with some regex and then loop through each statement apart from the first line to ensure that the code is using our internal commands Get-SQLInstance or Get-ComputerName to get information, that we are looping through each of those arrays using the ForEach method rather than ForEach-Object and using $psitem rather than $_ to reference the â€œThis Itemâ€ in the array and that each Describe block has a context block.&lt;/p>
&lt;p>This should ensure that any new tests that are added to the module follow the guidance we have set up on the Wiki and ensure that the Power Bi results still look beautiful!&lt;/p>
&lt;p>Anyone can run the tests using&lt;/p>
&lt;pre>&lt;code>Invoke-Pester .\\tests\\Unit.Tests.ps1 -show Fails
&lt;/code>&lt;/pre>
&lt;p>before they create a Pull request and it looks like&lt;/p>
&lt;p>&lt;img src="https://blog.robsewell.com/assets/uploads/2018/01/02-Pester-results-1.png"
loading="lazy"
>&lt;/p>
&lt;p>if everything is Green then they can submit their Pull Request ðŸ™‚ If not they can see quickly that something needs to be fixed. (fail early ðŸ™‚ )&lt;/p>
&lt;p>&lt;img src="https://blog.robsewell.com/assets/uploads/2018/01/03-fails.png"
loading="lazy"
alt="03 fails.png"
>&lt;/p></description></item></channel></rss>